From Peter Ware Subject Frequently Asked Questions FAQ Archive name Xt FAQ Version Id FAQ Xt v ware Exp The X Toolkit Intrinsics A monthly posting This article contains the answers to some Frequently Asked Questions FAQ from about the X Toolkit To submit questions preferably with an answer send email to Many FAQs including this one are available on the archive site in the directory pub usenet The name under which a FAQ is archived appears in the Archive name line at the top of the This FAQ is archived as Xt All code fragments are public Contents Xt Glossary Software Versions Related FAQ's Why does my application core dump when I use signals alarms cthreads How do I use a different visual than the default Which visual should an application use Why do only Shell widgets have a Visual Which visual depth and colormap do Shells inherit I've done all the above and I still get a BadMatch Why Why doesn't my widget get destroyed when I call XtDestroyWidget How do I exit but still execute the DestroyCallbacks How do I resize a Shell widget Why can't XtAppAddInput handle files What good books and magazines are there on Xt What Widgets are available What alternatives to the Intrinsics are there How do I pass a float value to XtSetValues How do I write a resource converter How do I open multiple displays What changed from to to Where are the resources loaded from What order are callbacks executed in How do I know if a widget is visible How do I reparent a widget in Xt XtReparentWidget Why use XtMalloc XtFree etc How to debug an Xt application Why don't XtAddInput XtAddTimeout and XtAddWorkProc work What is and how can I implement drag and drop Xt Glossary o The Xt Intrinsics implement an object oriented interface to C code to allow useful graphical components to be Included with this are classes that provide the base functionality Object RectObj Core Composite Constraint Shell OverrideShell WMShell The terms Xt and Intrinsics are used interchangeably however they are used very precisely to mean a specific library of the X window In particular it does not include the Athena Motif OLIT or any other widget Without further widgets the Intrinsics are not especially o A widget refers to a user interface abstraction created via The precise use is any object that is a subclass of the Core It is used loosely to refer to anything that is a subclass of the Object class although these are more accurately called windowless widgets or o Xlib is the C interface to the It is one layer below the Xt Typically a widget uses relatively few Xlib functions because Xt provides most such services although an understanding of Xlib helps with Software Versions The following are the latest versions of Xt based software Software Version Released Next Expected patch none patch Athena Widgets see Motif OLIT Xtra Xw none Xcu none fwf Related FAQ's David Lewis uunet craft faq maintains the FAQ on It is posted monthly on and located on export in contrib Liam Quin posts an FAQ list on Open Look to Jan Newmarch posts an FAQ list on Motif to Peter Ware posts an FAQ list for it is on export in contrib FAQ Why does my application core dump when I use signals alarms cthreads In brief Xlib Xt and most widget sets have no mutual exclusion for critical Any interrupt handler is likely to leave one of the above libraries in an inconsistent state such as all the appropriate flags not yet set dangling pointers in the middle of a list traversal Note that the ANSI C standard points out that behavior of a signal handler is undefined if the signal handler calls any function other than signal itself so this is not a problem specific to Xlib and Xt the POSIX specification mentions other functions which may be called safely but it may not be assumed that these functions are called by Xlib or Xt The only safe way to deal with signals is to set a flag in the interrupt This flag later needs to be checked either by a work procedure or a timeout It is incorrect to add either of these in the interrupt As another note it is dangerous to add a work procedure that never This effectively preempts any work procedures previously added and so they will never be Another option is to open a pipe tell the event loop about the read end using XtAppAddInput and then the signal handler can write a byte to the write end of the pipe for each However this could deadlock your process if the pipe fills Why don't the Intrinsics deal with this problem Primarily because it is supposed to be a portable layer to any hardware and operating Is that a good enough reason I don't think Note the article in The X Journal and the example in O'Reilly Volume are in How do I use a different visual than the default This requires a more complicated answer than it A window has three things that are visual specific the visual colormap and border All widgets have their own Colormap and BorderPixmap resource only shell widgets have Visual resources another questions deals with why shells have a Visual The default value of these resources is CopyFromParent which does exactly what it In the shell widget CopyFromParent gets evalulated as DefaultVisualOfScreen and When any one of the three resources is not properly set a BadMatch error occurs when the window is They are not properly set because each of the values depends on the visual being How to get this to work There are two parts to the The first is if you want an application to start with a particular visual and the second is if you want a particular shell within an application to start with a different The second is actually easier because the basic information you need is The first is a little harder because you'll need to initialize much of the toolkit yourself in order to determine the needed Some sample code to start up an application using something other than the default To compile cc g o visual lXaw lXmu lXt lXext lm To run visual geometry depth visual StaticColor fg blue bg yellow you need to move the mouse to get the particular visuals colormap to include include include typedef struct Visual visual int depth OptionsRec OptionsRec Options XtResource resources visual Visual XtRVisual sizeof Visual XtOffsetOf OptionsRec visual XtRImmediate NULL depth Depth XtRInt sizeof int XtOffsetOf OptionsRec depth XtRImmediate NULL XrmOptionDescRec Desc visual visual XrmoptionSepArg NULL depth depth XrmoptionSepArg NULL int main argc argv int argc char argv XtAppContext app the application context Widget top toplevel widget Display dpy display char xargv saved argument vector int xargc saved argument count Colormap colormap created colormap XVisualInfo vinfo template for find visual XVisualInfo vinfo list returned list of visuals int count number of matchs only Arg args Cardinal cnt char name test char class Test save the command line arguments xargc argc xargv char XtMalloc argc sizeof char bcopy char argv char xargv argc sizeof char The following creates a dummy toplevel widget so we can retrieve the appropriate visual cnt top XtAppInitialize app class Desc XtNumber Desc argc argv String NULL args cnt dpy XtDisplay top cnt XtGetApplicationResources top Options resources XtNumber resources args cnt cnt if DefaultVisualOfScreen XtScreen top XtSetArg args cnt XtNvisual cnt Now we create an appropriate We could use a default colormap based on the class of the visual we could examine some property on the rootwindow to find the right colormap we could do all sorts of colormap XCreateColormap dpy RootWindowOfScreen XtScreen top AllocNone XtSetArg args cnt XtNcolormap colormap cnt Now find some information about the XVisualIDFromVisual vinfo list XGetVisualInfo dpy VisualIDMask vinfo count if vinfo list count XtSetArg args cnt XtNdepth vinfo list cnt XFree XPointer vinfo list XtDestroyWidget top Now create the real toplevel XtSetArg args cnt XtNargv xargv cnt XtSetArg args cnt XtNargc xargc cnt top XtAppCreateShell char NULL class applicationShellWidgetClass dpy args cnt Display the application and loop handling all XtRealizeWidget top XtAppMainLoop app return Which visual should an application use This is a point that can be argued about but one opinion is there is no way for an application to know the appropriate visual it has to be specified by the If you disagree with this then your application probably falls into the category of always using the default visual or it is hardware specific and expects some particular visual such as TrueColor with an OverlayPlane extension or some such Why No application runs in Depending on the way a server allocates resources I may not always want your application to run in TrueColor mode if it is going to mess up my other I may be very upset if it chooses to run in GreyScale instead of PsuedoColor or just As an example on a low end color Sun server there are many different possible visuals monochrome entry colormap static gray static color and a The SGI Iris's offer all the above plus bit TrueColor bit TrueColor an Overlay Why do only Shell widgets have a Visual This is strictly by It makes it possible for an arbitrary widget to know that the visual it uses can be found by looking for the shell widget that is its ancestor and obtaining the visual of that A widget can have its own visual If it does it must have its own realize method to use the visual when it calls XCreateWindow You should also make this a resource that can be obtained with XtGetValues so other widgets can find A reasonable value is probably Which visual depth and colormap do Shells inherit The default value for these resources are set to This is interpreted as the DefaultColormapOfScreen DefaultDepthOfScreen and the default visual of the screen if the widget has no parent it is an applicationShellWidgetClass and the root of your widget If the parent of the widget is not null then the shell copies colormap and depth from its parent and uses CopyFromParent as the I've done all the above and I still get a BadMatch Why Some resource converters improperly cache This was especially true of and earlier versions of Why doesn't my widget get destroyed when I call XtDestroyWidget See section of the Xt It eventually does get destroyed just not The Intrinsics destroy a widget in a two phase First it and all of its children have a flag set that indicate it is being It is then put on a list of widgets to be This way any pending X events or further references to that widget can be cleaned up before the memory is actually The second phase is then performed after all callbacks event handlers and actions have completed before checking for the next X At this point the list is traversed and each widget's memory is actually free 'd among other As some further caveats trivia the widgets may be destroyed if the Intrinsics determine that they have no further references to the widgets on the If so then the phase destruction occurs Also if nested event loops are used widgets placed on the destroy list before entering the inner event loop are not destroyed until returning to the outer event How do I exit but still execute the DestroyCallbacks The problem is if a simple and entirely reasonable approach to exiting an application is used such as calling exit directly then a widget may not have a chance to clean up any external state such as open sockets temporary files allocated X resources this code for simplicity reasons assumes only a single toplevel widget Widget ToplevelGet gw Widget gw widget to find toplevel Widget top for top gw XtParent top top XtParent top empty return top void ExitCallback gw closure call data Widget gw widget XtPointer closure data the app specified XtPointer call data widget specific data Widget toplevel toplevel ToplevelGet gw XtUnmapWidget toplevel make it disappear quickly XtDestroyWidget toplevel exit One can see that the above code exit's immediately after destroying the toplevel The trouble is the phase destruction may never This works for most widgets and most applications but will not work for those widgets that have any external You might think that since it works now it will always work but remember that part of the reason an object oriented approach is used is so one can be ignorant of the implementation details for each Which means that the widget may change and someday require that some external state is cleaned up by the Destroy One alternative is to modify ExitCallback to set a global flag and then test for that flag in a private event However private event loops are frowned upon because it tends to encourage sloppy and difficult to maintain Try the following code include extern Widget ToplevelGet if NeedFunctionPrototypes Widget gw endif extern Boolean ExitWorkProc if NeedFunctionPrototypes XtPointer closure endif extern void ExitCallback if NeedFunctionPrototypes Widget gw XtPointer closure XtPointer call data endif Widget ToplevelGet gw Widget gw widget to find toplevel Widget top for top gw XtParent top top XtParent top empty return top void ExitCallback gw closure call data Widget gw widget XtPointer closure data the app specified XtPointer call data widget specific data Widget toplevel toplevel ToplevelGet gw XtUnmapWidget toplevel make it disappear quickly XtDestroyWidget toplevel XtAppAddWorkProc XtWidgetToApplicationContext gw ExitWorkProc XtPointer NULL Boolean ExitWorkProc closure XtPointer closure exit NOTREACHED ExitCallback adds a work procedure that will get called when the application is next idle which happens after all the events are processed and the destroy callbacks are How do I resize a Shell widget After it is realized one doesn't resize a Shell The proper thing is to resize the currently managed child of the Shell widget using XtSetValues The geometry change is then propagated to the Shell which asks the window manager which may or may not allow the However the Shell must have the resource XtNallowShellResize set to True otherwise it will not even ask the window manager to grant the request and the Shell will not To change the position of a Shell use XtSetValues on the Shell not the child and within the limits of the window manager it should be Why can't XtAppAddInput handle files It does however Unix semantics for when I O is ready for a file does not fit most peoples' intuitive In Unix terms a file descriptor is ready for reading whenever the read call would not block ignoring the setting of optional flags that indicate not to This works as expected for terminals sockets and For a file the read will always return but the return indicates an EOF no more The result is the code in the Intrinsics always calls the input handler because it always thinks something is about to be The culprit is the select system call or on SYSV based OS's it is the poll system How to get around this on a Unix system The best approach is to use another process to check for available input on the Use a pipe to connect the application with this other process and pass the file descriptor from the pipe to XtAppAddInput A suitable program on BSD systems is tail f filename It's rumored that select on some systems is not completely In particular IBM AIX this is one where it would work for a while several thousand times and then stop until some other event woke it This seemed to be the result of a race condition in the IBM claims to have a fix for Pyramid doesn't work at Ultrix and possibly others where pipes are implemented as sockets wasn't completely broken but although the writing side wrote in byte blocks the reading side received it all broken up as if it was being put into the pipe a byte at a You can waste a lot of time by reading small blocks get raound it by detecting the situation and having select ignore the pipe for mseconds by then it had been given the whole block Note that all the above descriptions used Unix terminology such as read file descriptor pipes This is an OS dependent area and may not be identical on all However the Intrinsic designers felt it was a common enough operation that it should be included with part of the Why they didn't also deal with signals at this point I don't What good books and magazines are there on Xt I have a favorite that is the definitive To my perspective it offers a reasonable introduction but also goes into the full details of the When I started using it I was already familiar with Xt and the concepts behind it so newcomers may or may not find it I've always found it accurate and complete which means its a Asente Paul and Swick Ralph X Window System Toolkit The Complete Programmer's Guide and Specification Digital Press ISBN order number EY DP and by Prentice Hall ISBN Also available through DEC Direct at The other book I commonly recomend to novices is Young The X Window System Applications and Programming with Xt Motif Version Prentice Hall ISBN ISBN And of course O'Reilly has an entire series of manuals on X and O'Reilly ordering is In particular Volume is an Xt reference done in manual page The edition is extensively overhauled and goes far beyond the MIT manual I'm finding it very In particular the permutted index and references to other manual pages help a great deal in chasing down related I read two periodicals The X Resource and the The X Journal These are the only two dealing specifically with The X Resource is published quarterly by O'Reilly with one of the issues being the MIT X Consortium Technical Conference There is no I've found it informative with pretty good For orders call or email For editorial matters email Table of contents are posted at in ftp pub tex bib in TeX form and on in ftp published oreilly xresource in ASCII The X Journal is a bimonthly trade rag with lots of The articles are informative and oriented toward a less technical I read it more to see what's going on then with an expectation of learning a great deal but remember I represent a fairly small percentage of people Also they have a pretty good collection of people on the advisory board and as Call What Widgets are available There are three popular widget sets Athena The set provided with This is sufficient for most purposes but is on the ugly Recently a look is available for ftp on contrib Motif From OSF available for a license fee and commonly shipped on many workstation vendors platforms almost everyone but Sun It looks good and works well but personally I think it is poorly OLIT The Open Look Intrinsics Toolkit is a set of widgets implementing Sun's Open Look Developed by AT I've never used it so can't comment on its I've heard rumours that it is a pain to actually In addition the following collection of widgets are also available Xtra a library of widgets for sale from Graphical Software Technology It includes bar graph stacked bar graph line graph pie chart xy plot hypertext help spreadsheet and data entry form I've never seen them so I can't FWF The Free Widget Foundation is attempting to collect a set of freely available Included are a Pixmap editor FileDialog and a few The current set of widgets can be obtained via anonymous ftp from the machine in the file pub Xcu The Cornell University widgets from Gene One of the early widget sets Provides a nice appearance for buttons and has a mini command Probably not so widely Xs The Sony widget This was around during days but seemed to It looked like it had Xw The HP The precursor to Originally written for there exists diffs to get it to work under Again a pretty good widget set but has more or less The precursor to this was the Xray toolkit which was originally implemented for and apparently provided much experience for the designers of Xo A widget set I'm working It's still primitive but you can give it a try in pub Xo The following specialized widgets are also available Tbl Implements a tabular layout of Supports Motif widgets as Part of Plots The Athena Plotting widgets not the Athena widgets Contact or joe What alternatives to the Intrinsics are there Name Language Vendor Xview C Sun OI C ParcPlace Interviews C Stanford Tcl tk C However much I like C and admire the skill in both designing and implementing the Intrinsics hopefully some alternative will develop in the next years that uses an object oriented Keep your eyes open and expect some change about the same time a language other than C starts gaining How do I pass a float value to XtSetValues First what is going wrong is the structure for an Arg is essentially typdef struct String name long value Arg and the code Arg arg XtSetArg arg name expands to Arg arg name you can see that with normal C type conversions the gets the integer instead of the floating point value When the value is copied into the widget resource the bit pattern is wildly different than that required for a floating point So how to get around this The following macro is from the Athena widgets document and I am now recomending it over the previous define XtSetFloatArg arg n d if sizeof float sizeof XtArgVal XtSetArg arg n d else XtArgVal ld XtArgVal d XtSetArg arg n ld How do I write a resource converter Courtesy of Rich Thomson The following discussion of resource converters assumes or Resource converters changed between and to allow for destructors and caching of converted There are several main types of resource converters string to data type data type to string data type to data type i string to data type Usually a string to data type converter has a fixed set of strings that will be converted to data type This is most often used to map enumerated names to enumerated values Name Value True False In this case the string to data type converter needs to compare the resource value to the list of fixed This is most readily accomplished by the use of the quark mechanism of the resource The resource value is turned into a quark which is a unique representation of the string that fits into a single Then the resource quark is compared against the quarks for the fixed strings representing the enumerated If there are many enumerated strings in the converter or many converters each with a small number of enumeration strings then a global initialization routine might be used to turn all the resource strings into That way the first time one of these converters is used the strings will be turned into quarks and held in static variables for use in the next invocation of one of the ii data type to string This type of converter is slightly easier than the string to data type converters since the use of quarks isn't Instead the data type value is simply converted to a string value probably by the use of Data type to string converters are useful for applications that wish to convert an internal data type value into a string so that they can write out a valid resource specification to a This mechanism can be used to provide a snapshot of application state into a This snapshot can be used to restore the program to a known state via the usual X resource database If you are taking the trouble to write a string to data type converter it isn't much extra effort to write the data type to string Writing both at the same time helps to ensure that they are iii data type to data type This type of converter is used to convert an existing data type value to another data For instance an X pixel value can be converted to an RGB data type that contains separate fields for red green and The type signature for a resource converter is as follows typedef Boolean XtTypeConverter Display XrmValuePtr Cardinal XrmValuePtr XrmValuePtr XtPointer Display dpy XrmValuePtr args Cardinal num args XrmValuePtr fromVal XrmValuePtr toVal XtPointer converter data When the converter is invoked the fromVal argument points to the source X resource manager value and the toVal argument points to the destination X resource manager The converter data argument is an opaque pointer to some converter specific data that is specified when the converter is The args and num args arguments allow extra information to be passed to the converter when it is For instance the Pixel to RGB structure converter discussed above would need colormap and visual arguments in which to lookup the Pixel to obtain the RGB values corresponding to that Care must be taken with the toVal An XrmValue has the following type definition and specifies a size and location for a converted value typedef struct unsigned int size caddr t addr XrmValue XrmValuePtr When the converter is invoked the address may point to a location of the given size for the converted value or the location can be In the former case the converter should ensure that the size of the destination area is large enough to handle the converted If the destination area is not large enough then the converter should set the size to the amount of space needed and return The caller can then ensure that enough space is allocated and reinvoke the If the size is large enough then the converter can simply copy the converted value into the space given and return If the location is NULL then the converter can assign the location to the address of a static variable containing the converted value and return When writing a group of converters this code is often repeated and it becomes convenient to define a macro define DONE var type if toVal addr if toVal size sizeof type toVal size sizeof type return False else type toVal addr var else toVal addr caddr t var toVal size sizeof type return True define DONESTR str if toVal addr toVal size sizeof String toVal size sizeof String return False else toVal addr caddr t str toVal size sizeof String return True Inside the converter it is a good idea to perform a little safety checking on the num args and args arguments to ensure that your converter is being called Once you have written your converter you need to register it with the The Intrinsics invokes resource converters when creating widgets and fetching their resource values from the resource To register a converter with a single application context use XtAppSetTypeConverter void XtAppSetTypeConverter context from to converter args num args cache destructor XtAppContext context String from String to XtTypeConverter converter XtConvertArgList args Cardinal num args XtCacheType cache XtDestructor destructor To register a converter with all application contexts use XtSetTypeConverter void XtSetTypeConverter from to converter args num args cache destructor String from String to XtTypeConverter converter XtConvertArgList args Cardinal num args XtCacheType cache XtDestructor destructor In the Intrinsics there were the routines XtAppAddConverter and XtAddConverter these have been superseded by XtAppSetTypeConverter and Whenever possible the newer routines should be When a converter is registered with the Intrinsics a cache argument specifies how converted resource values are to be cached XtCacheNone Don't cache any converted values XtCacheAll Cache all converted values XtCacheByDisplay Cache converted values on a per display basis Caching converted values that require a round trip to the server is a good idea for instance string to Pixel conversions The destructor argument is a routine that is invoked then the resource is destroyed either because its cached reference count has been decremented to zero or because the widget owning the value is being XtDestructor has the following type definition typedef void XtDestructor XtAppContext XrmValuePtr XtPointer XrmValuePtr Cardinal XtAppContext context XrmValuePtr to XtPointer converter data XrmValuePtr args Cardinal num args The destructor is invoked to free any auxiliary storage associated with the to argument but does not actually free the storage pointed to by the to argument itself to addr The destructor is passed the extra arguments that were passed to the converter when the conversion was performed for instance colormap and visual arguments for the string to Pixel converter since the destructor would need to free the allocated Pixel from the colormap as well as the private data passed in when the converter was Sample converter code can be found in the following files in the MIT distribution mit lib Xt contrib lib PEXt contrib lib PEXt How do I open multiple displays See Multi user Application Software Using Xt The X Resource Issue Summer by Oliver Jones for a complete coverage of the issues Most of this answer is based on that In a nutshell one uses XtOpenDisplay to add each display to a single application context and then XtCloseDisplay to shutdown each display and remove it from the application The real problems occur when trying to close down a This can happen ways User selects a quit button on one of the displays User has window manager send a WM DELETE WINDOW message Server disconnect possibly from a KillClient message server shutdown crash or network I'll assume you can deal gracefully with since it is merely a problem of translating a Widget to a display and removing that If not then read the Oliver Jones The third one is difficult to The following is based on the Oliver Jones article and I include it here because it is a difficult The difficulty arises because the Xlib design presumed that an I O error is always unrecoverable and so This is essentially true for a single display X based application but not true for a multiple display program or an application that does things other than display information on an X When an X I O error occurs the I O error handler is called and if it returns then an exit The only way around this is to use setjmp longjmp to avoid returning to the I O error The following code fragment demonstrates this include jmp buf XIOrecover void XIOHandler dpy Display dpy destroyDisplay dpy longjmp XIOrecover main if setjmp XIOrecover XSetIOErrorHandler XIOHandler XtAppMainLoop app context The destroyDisplay is something that given a Display pointer can go back to the application specific data and perform any necessary It should also call XtCloseDisplay For those of you unfamiliar with setjmp longjmp when setjmp is first called it returns a and save's enough information in the jmp buf that a latter execution of longjmp can return the program to the same state as if the setjmp was just The return value of this second setjmp is the value of the second argument to longjmp There are several caveats about using these but for this purpose it is Some other problems you might run into are resource converters that improperly cache The most likely symptoms are Xlib errors such as BadColor BadAtom or There may be problems with the total number of displays you can open since typically only a limited number of file descriptors are available with being a typical You may also run into authorization problems when trying to connect to a There was much discussion in about this topic in November of Robert Scheifler posted an article which basically said this is the way it will be and Xlib will not What changed from to to This addresses only changes in the First the general changes for each release are Then a certainly incomplete list of new functions added and others that are now deprecated are Brevity is a primary Much of the following information is retrieved from Chapter of the MIT Xt Intrinsics Manual and from O'Reilly Volume From to Addition of gadgets windowless widgets New resource type converter interface to handle cacheing and additional Variable argument list define XtSpecificationRelease added with this release WMShellPart TopLevelShellPart TransientShellPart changed values added ArgList and count parameters event handlers had continue to dispatch parameter added values almost specification exposure changed to an enumerated data type from Boolean inited changed to enumerated data type from Boolean values hook added to extension record hook obsolete as info is passed to geometry manager added to extension record values hook obsolete as info is passed to values Calling XtQueryGeometry must store complete Added XtTranslateCoords actually works under From to Psuedo resource baseTranslation Searching for app default and other files made more flexible customization resource Per screen resource Support permanently allocated Permanetly allocated strings required for several class The args argument to XtAppInitialize XtVaAppInitialize XtOpenDisplay XtDisplayInitialize and XtInitialize were changed from Cardinal to int Many performance improvements this is summarized from the article Xt Performance Improvements in Release by Gabe Beged Dov in The X Resource Issue XrmStringToQuark augmented with XrmPermStringToQuark to avoid string Several fields in the class record are indicated as needing permanent Using an array of Strings for resources Callback lists redesigned to use less memory Translation manager redesigned and rewritten so it takes less memory translation tables merges are faster cache of action bindings Keycode to Keysyms are Better sharing of GC's with modifiable fields Window to Widget translation uses less space and faster Does not malloc space for widget name since quark is available Widget space is allocated to include the constraints Over several example programs about a reduction in memory Functions new with XtAllocateGC sharable GC with modifiable fields XtGetActionList get the action table of a class XtScreenDatabase return resource database for a screen XtSetLanguageProc register language procedure called to set locale Functions new with XtAppAddActionHook procedure to call before every XtAppInitialize lots of initialization XtAppReleaseCacheRefs decrement cache reference count for converter XtAppSetFallbackResources specify default resources XtAppSetTypeConverter register a new style converter XtCallCallbackList directly execute a callback list XtCallConverter invoke a new style converter XtCallbackReleaseCacheRef release a cached resource value XtCallbackReleaseCacheRefList release a list of cached resource values XtConvertAndStore find and call a resource converter XtDirectConvert Invoke old style converter XtDisplayOfObject Return the display XtDisplayStringConversionWarning issue a warning about conversion XtFindFile Find a file XtGetActionKeysym Retrieve keysym modifies for this action XtGetApplicationNameAndClass return name and class XtGetConstraintResourceList get constraints for a widget XtGetKeysymTable return keycode to keysym mapping table XtGetMultiClickTime read the multi click time XtGetSelectionRequest retrieve the SelectionRequest event XtGetSelectionValueIncremental obtain the selection value incrementally XtGetSelectionValuesIncremental obtain the selection value incrementally XtInitializeWidgetClass initialize a widget class manually XtInsertEventHanlder register event handler before after others XtInsertRawEventHandler register event handler without modify input mask XtIsObject test if subclass of Object XtIsRectObj test if subclass of RectObj XtKeysymToKeyCodeList return list of keycodes XtLastTimestampProcessed retrieve most recent event time XtMenuPopdown Action for popping down a widget XtMenuPopup Action for popping up a widget XtOffsetOf macro for structure offsets XtOwnSelectionIncremental make selection data availabe incrementally XtPoupSpringLoaded map a spring loaded popup XtRegisterGrabAction indicate action procedure needs a passive grab XtRemoveActiohHook remove function called after every action XtResolvePathname find a file XtScreenOfObject return screen of XtSetMultiClickTime set the multi click time XtSetWMColormapWindows set WM COLORMAP WINDOWS for custom colormaps XtUngrabButton cancel a passive button grab XtUngrabKey cancel a passive key grab XtUngrabKeybard release an active keyboard grab XtUngrabPointer release an active pointer grab XtVa varags interfaces to a bunch of functions XtWindowOfObject return Window of nearest widget ancestor Deprecated Replacement When XtAddActions XtAppAddActions XtAddConverter XtAppAddConverter XtAddInput XtAppAddInput XtAddTimeout XtAppAddTimeout XtAddWorkProc XtAppAddWorkProc XtConvert XtConvertAndStore XtCreateApplicationShell XtAppCreateShell XtDestroyGC XtReleaseGC XtError XtAppError XtGetErrorDatabase XtAppGetErrorDatabase XtGetErrorDatabaseText XtAppGetErrorDatabaseText XtGetSelectionTimeout XtAppGetSelectionTimeout XtInitialize XtAppInitialize XtMainLoop XtAppMainLoop MenuPopdown action XtMenuPopdown action MenuPopup action XtMenuPopup action XtNextEvent XtAppNextEvent XtPeekEvent XtAppPeekEvent XtPending XtAppPending XtSetErrorHandler XtAppSetErrorHandler XtSetErrorMsgHandler XtAppSetErrorMsgHandler XtSetSelectionTimeout XtAppSetSelectionTimeout XtSetWarningHandler XtAppSetWarningHandler XtSetWarningMsgHandler XtAppSetWarningMsgHandler XtWarning XtAppWarning XtWarningMsg XtAppWarningMsg Where are the resources loaded from The resources of a widget are filled in from the following places from highest priority to lowest priority Args passed at creation Command line User's per host defaults file User's defaults User's per application default System wide per application default Note that are read only once on application The result of steps is a single resource database used for further The per host defaults file contains customizations for all applications executing on a specific This file is either specified with the XENVIRONMENT environment variable or if that is not set then the file HOME host is The user defaults file is either obtained from the RESOURCE MANAGER property on the root window of the display or if that is not set then the file HOME is Typically the program xrdb is used to set the RESOURCE MANAGER Please note that this should be kept relatively small as each client that connects to the display must transfer the A size of around is Some toolkits may track changes to the RESOURCE MANAGER but most do A user may have many per application default files containing customizations specific to each The intrinsics are quite flexible on how this file is Read the next part that describes the various environment variables and how they effect where this file is The system wide per application default files are typically found in usr lib app If such a file is not found then the fallback resources are The intrinsics are quite flexible on how this file is Read the next part that describes the various environment variables and how they effect where this file is Thanks to Oliver Jones for the following You can use several environment variables to control how resources are loaded for your Xt based programs XFILESEARCHPATH XUSERFILESEARCHPATH and These environment variables control where Xt looks for application defaults files as an application is Xt loads at most one app defaults file from the path defined in XFILESEARCHPATH and another from the path defined in Set XFILESEARCHPATH if software is installed on your system in such a way that app defaults files appear in several different directory Suppose for example that you are running Sun's Open Windows and you also have some X applications installed in usr lib app You could set a value like this for XFILESEARCHPATH and it would cause Xt to look up app defaults files in both usr lib and usr openwin lib or wherever your OPENWINHOME is located setenv XFILESEARCHPATH usr lib T N OPENWINHOME lib T N The value of this environment variable is a colon separated list of The pathnames contain replacement characters as follows see XtResolvePathname N The value of the filename parameter or the application's class T The value of the file type In this case the literal string app defaults C customization resource only S None for app L Language locale and codeset ja l Language part of L ja t The territory part of the display's language string c The codeset part of the display's language string Let's take apart the Suppose the application's class name is Myterm Also suppose Open Windows is installed in usr Notice the example omits locale specific usr lib T N means usr lib app defaults Myterm OPENWINHOME lib T N means usr openwin lib app defaults Myterm As the application initializes Xt tries to open both of the above app defaults files in the order As soon as it finds one it reads it and uses it and stops looking for The effect of this path is to search first in usr lib then in usr Let's consider another This time let's set XUSERFILESEARCHPATH so it looks for the file in the current working directory then for Myterm in the directory app setenv XUSERFILESEARCHPATH HOME app defaults N The first path in the list expands to The second expands to HOME app defaults This is a convenient setting for debugging because it follows the Imake convention of naming the app defaults file in the application's source directory so you can run the application from the directory in which you are working and still have the resources loaded NOTE when looking for app default files with XUSERFILESEARCHPATH for some bizarre reason neither the type nor file suffix is defined so T and S are With there's another You may specify a customization resource For example you might run the myterm application like this myterm xrm customization color If one of your pathname specifications had the value usr lib app defaults N C then the expanded pathname would be usr lib app defaults Myterm color because the C substitution character takes on the value of the customization The default XFILESEARCHPATH compiled into Xt is usr lib L T N C usr lib l T N C usr lib T N C usr lib L T N usr lib l T N usr lib T N Note some sites replace usr lib with a ProjectRoot in this batch of default The default XUSERFILESEARCHPATH also compiled into Xt is root L N C root l N C root N C root L N root l N root N root is either the value of XAPPLRESDIR or the user's home directory if XAPPLRESDIR is not If you set XUSERFILESEARCHPATH to some value other than the default Xt ignores XAPPLRESDIR Notice that the quick and dirty way of making your application find your app defaults file in your current working directory is to set XAPPLRESDIR to a single In all this machinery worked differently for compatibilty many people set their XAPPLRESDIR value to a dot followed by a What order are callbacks executed in Courtesy of Donna Converse The Intrinsics library do not guarantee an This is because both the widget writer and the application writer have the ability to modify the entire contents of the callback Neither one currently knows what the other is doing and so the Intrinsics cannot guarantee the order of The application programmer cannot rely on the widget writer the widget writer is not required to document when the widget will add and remove callbacks from the list or what effect this will have therefore the functionality contained in a callback should be independent of the functionality contained in other callbacks on the Even though the Xt standard in the definition of XtAddCallback says callback name Specifies the callback list to which the procedure is to be you may not infer from the word appended that the callback routines are called in the same order as they have been added to the callback How do I know if a widget is visible Courtesy of Donna Converse I am building a widget needs to know if it is I set the visible interest field in Core and if my window is completely obscured the Core visible flag goes However if my window is iconified the flag stays set to Right everything is implemented This demonstrates a deficiency in the X protocol and the Core widget is reflecting the capabilities of the The deficiency is that the information is available in one way in this case an inconvenient The Xt specification is accurate in the second and third paragraphs of section so read this section The visible field will not change in response to A VisibilityNotify event will not be received when the window goes from viewable to unviewable that is when the widget or an ancestor is unmapped that is when iconification This is the protocol Visibility state and viewable state have specific meanings in the X protocol see the glossary in your Xlib and X protocol reference Is this a problem with mwm or is there something else which needs to be done You'll see this with any window manager with no window If the problem is mwm what is the fastest way to determine if a window is iconified As an application writer keep track with a global Boolean in an action routine with translations for MapNotify and UnmapNotify on the Shell widget which contains your custom As the custom widget writer see the map state field returned by a call to These are How do I reparent a widget in Xt XtReparentWidget You can' Why use XtMalloc XtFree etc Unfortunately most code that calls malloc realloc or calloc tends to ignore the possibility of returning At best it is handled something like ptr type malloc sizeof type if ptr perror malloc in xyzzy exit To handle this common case the Intrinsics define the functions XtMalloc XtCalloc XtNew XtNewString and XtRealloc which all use the standard C language functions malloc calloc and realloc but execute XtErrorMsg if a NULL value is Xt error handlers are not supposed to return so this effectively In addition if XtRealloc is called with a NULL pointer it uses XtMalloc to get the initial This allows code like if ptr ptr type malloc sizeof type else ptr type realloc ptr sizeof type count count to be written as ptr XtRealloc ptr sizeof ptr count Also XtFree accepts a NULL pointer as an Generally I've found the Xt functions conveniant to However anytime I'm allocating anything potentially large I use the standard functions so I can fully recover from not enough memory XtNew and XtNewString are conveniant macros for allocating a structure or copying a string struct abc xyzzy char ptr char str abcdef xyzzy XtNew struct abc takes care of type casting ptr XtNewString str A strict interpretation of the Intrinsics reference manual allow an implementation to provide functions that are not exchangable with malloc and free code such as char ptr ptr XtMalloc free ptr may not Personally I'd call any implementation that did this broken and complain to the A common error for Motif programmers is to use XtFree on a string when they should really be using XmStringFree How to debug an Xt application First I'd recomend getting purify from Pure This is a great package for tracing memory problems on Sun' It's a bit pricey at but I'd still recomend Excuse the marketing blurb contact for more info Purify inserts additional checking instructions directly into the object code produced by existing These instructions check every memory read and write performed by the program under test and detect several types of access errors such as reading unitialized memory writing past malloc'd bounds or writing to freed Purify inserts checking logic into all of the code in a program including third party and vendor object code libraries and verifies system call In addition Purify tracks memory usage and identifies individual memory leaks using a novel adaption of garbage collection Purify's nearly comprehensive memory access checking slows the target program down typically by a factor of two to An alternative package that isn't as pricey for a Sun runs on many Unix's and has pretty similar features is The SENTINEL Debugging Environment This replaces malloc and several other C library functions to add additional contact for more info Next if you are getting any sort of Xlib error you'll need to run in synchronous mode easily accomplished with the sync command line argument or by setting the variable Xdebug to with your Then set a break point in exit This will let you trace back to the original Xlib function being If you don't run in synchronous mode then the actual error may have occured any number of calls to Xlib previously since the Xlib calls are buffered and replies from the server are Next if you are having trouble with window layout you can use the undocumented resource xtIdentifyWindows or the class resource XtDebug to cause the widget name to be identified with each For example example xload xrm ' XtDebug true' example xwininfo tree click in new xload window will give the normal information but the widget name and class of each window is This can help for checking the location and size of errant Next if you are having trouble with geometry managers or you want to test the way a widget manages it's children you can try contrib This acts as a filter between any children and a geometry manager and checks the behaviour of It's a very clever The most unfortunate problem is debugging a callback while the application is executing a grab of the keyboard or mouse such as from a pulldown menu The server effectively locks up and you'll need to go to another machine and kill the debugger The server locks up because the application being debugged has said no one else can have access to the keyboard but the application is not stopped waiting because the debugger is waiting for your Unfortunately you can't give them because all the input is going to your application which is The best way to debug this kind of problem is with two machines on your desk running the program under a debugger or other environment on one machine and running the application on the other possibly using a command sequence like this othermachine xhost thismachine thismachine setenv DISPLAY othermachine thismachine gdb application Your favorite or this othermachine xhost thismachine thismachine gdb application gdb set environment DISPLAY othermachine gdb run I believe CodeCenter a C interpreter graphical debugger has a method of dealing with this by explicitely calling the Xlib functions to release any grabs during Debugging widget problems requires pretty good debugging skills and knowledge of how widgets You can go a long way without knowing the internals of a particular widget but not very far without understanding how a widget Judicious use of conditional breakpoints and adding print statements with the debugger help a great Why don't XtAddInput XtAddTimeout and XtAddWorkProc work I have got a delicate problem with the three routines XtAddInput XtAddTimeOut and The problem I have is that when I use them in my application they seem not to be registred I have made a handy little testprogram where everything works perfect but in my real application nothing The introduction in of the XtApp functions obsoleted those routines see for other changes in and What happens is they use a default application context different then the one you may have Since events and timeouts are distributed on a per application context basis and you are using two application contexts you won't get those For example cnt toplevel XtAppInitialize app class Desc XtNumber Desc argc argv Fallback args cnt XtAddTimeOut XtAddWorkProc XtAppMainLoop app would never invoke the What is and how can I implement drag and drop Courtesy of Roger Reynolds Feb Drag n drop is a buzzword for moving data between clients in an intuitive'' Motif Version supports drag n drop capabilities OpenLook has supported d n d all The two protocols are not compatable with each other and so far as I know they are not I wrote a package called RDD which is designed to be a flexible public protocol for doing drag 'n drop operations between My intention was to provide a tool which would make it easy for people to support a standard drag n drop protocol in the programs they develop and contribute or sell regardless of what widget set is used as long as it is based on Xt The implementation is based upon my understanding of the ICCCM conventions for more details read the I have heard from dozens of people using RDD who like it and feel that it works a whole lot better than Motif Also there seem to be many who think that it is neat but are constrained to use Motif The latest RDD and some other stuff is available for ftp from in pub A possibly older version is also available on in Pete Ware CIS Dept Ohio State University w Bolz Hall Neil h Columbus OH