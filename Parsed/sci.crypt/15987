From Greg Onufer Subject Re Let's build software cryptophones for over the In Graham Toal writes In article Hal Finney writes I tried this code On my Sparcstation ELC it takes over seconds to compress seconds' worth of This means that it needs to be optimized by over a factor of before it will be usable in even a half duplex Ouch Thanks for trying The following program is a very quick hack I created a few months ago to determine whether a Sun Sparcstation IPC could perform real time full duplex encrypted audio with resulting data rates sustainable by today's This test program reads linearly encoded audio from the audio device compresses it with GSM compresses frames of bit samples recorded at into bits resulting in a Hz frame rate encrypts it with DES then reverses the process and sends the reconstructed audio back to the audio The compressed encrypted audio stream is kbits s My Sparcstation IPC not exactly a very fast machine these days certainly slower than an ELC would just barely sustain this activity audio underruns would occcur but the speech was very intelligible I ran it as a real time process to get the best Remember though that this program is a quick hack and the performance can certainly be The audio compression routines can be ftp'd from I believe look for gsm or toast I used Eric Young's DES implementation but I no longer know where I got it Cheers greg CUT HERE Test program to see how much CPU it takes for secure digital Written by Onufer greg Written on a Sun IPC running Solaris with a Sun ISDN S Bus card and a include include include include include sys include sys include include include boolean t svs audio init int fd audio info t prev info audio info t info if prev info NULL if ioctl fd AUDIO GETINFO prev info perror AUDIO GETINFO return B FALSE AUDIO INITINFO info B TRUE B TRUE rate AUDIO ENCODING LINEAR rate AUDIO ENCODING LINEAR size if ioctl fd AUDIO SETINFO info perror AUDIO SETINFO return B FALSE if ioctl fd I FLUSH FLUSHRW perror I FLUSH return B FALSE AUDIO INITINFO info B FALSE B FALSE if ioctl fd AUDIO SETINFO info perror AUDIO SETINFO return B FALSE return B TRUE boolean t svs in int ifd gsm handle gsm byte buf gsm signal sample if read ifd sample sizeof sample sizeof sample fprintf stderr svs in short read n return B FALSE gsm encode handle sample buf return B TRUE boolean t svs out int ofd gsm handle gsm byte buf gsm signal sample if gsm decode handle buf sample fprintf stderr svs out gsm decode failed n return B FALSE if write ofd sample sizeof sample sizeof sample fprintf stderr svs out short write n return B FALSE return B TRUE main gsm handle gsm frame frame int audiofd int option des cblock key ivec in ivec out des key schedule ks in ks out des cblock cbuf in cbuf out cbuf buf audiofd open dev audio O RDWR if audiofd perror open exit Initialize GSM compression code if handle gsm create NULL fprintf stderr svs gsm create failed n exit option B TRUE if gsm option handle GSM OPT FAST option fprintf stderr svs gsm option FAST failed n exit Initialize DES code des random key key if des set key key ks in fprintf stderr svs des set key failed n exit if des set key key ks out fprintf stderr svs des set key failed n exit memset ivec in sizeof ivec in memset ivec out sizeof ivec out Open audio device and configure it if svs audio init audiofd NULL exit for Get samples bit linear and convert to a byte frame if svs in audiofd handle frame exit Encrypt Decrypt block des cbc encrypt frame cbuf out long ks in ivec in DES ENCRYPT des cbc encrypt cbuf out cbuf buf long ks out ivec out DES DECRYPT memmove frame cbuf buf if if memcmp cbuf in cbuf buf fprintf stderr svs memcmp failed n exit endif Take byte frame and convert to samples and play if svs out audiofd handle frame exit gsm destroy handle CUT HERE